# 1. vm vs zk-vm
## vm
vm is a replicated state machine process as ` STF (current state, input data) -> new state `.

It begins with a genesis state; it changes its state based on user input and a set of rules; then it arrives at a new state. 

the STF can be implemented as on-chain logic or as user defined logic. And transactions will be verified by re-executing the STF using the user input data and comparing the results with each other. 

The re-execution method suffers several severe disadvantages: 1) Privacy 2) Scalability 3) Computation restriction
4) State Explosion
## zk-vm
zkp is a way to verify the validity (integrity) of a computation without re-execution.

computational integrity — with a tiny fraction of the efforts needed to actually perform the computation. 
we can prove the integrity of the STF execution without disclosing the input data or the computational process. We can also do long and complex computations off-chain and only leave the succinct proof on-chain for people to verify its integrity. 

## sample：evm vs l2 zk-rollup
Smart contracts are stored on the chain in the form of bytecodes. When a broadcast transaction is received, the node loads the corresponding contract from the storage and executes contract bytecodes in EVM.

At Layer 2, smart contracts are stored in storage as bytecodes. Transactions originate from off-chain and are executed in a centralized zkEVM node. ZkEVM generates a certificate showing that the virtual machine state has changed based on the transaction. When the proof is submitted to the smart contract at Layer 1, the contract does not re-execute the submitted transaction, but updates the status directly based on the proof.

# 2. how zk-vm works
zero-knowledge virtual machine allow developers to relatively easily write programs whose execution can be verified while keeping all or some inputs private, can verify any program of a supported size.

A ZK VM is a circuit that executes bytecode. It allows a prover to show that, given a set of inputs, as well as some bytecode(not the circuit itself, but part of its inputs), they have correctly executed the program code on said inputs.

a model of a zk-vm:
![a model of a zk-vm](https://ethresear.ch/uploads/default/original/2X/4/486ec227a17021ec1e78d7ed7a5c4d33f8cf8ef5.png)

The VM:
- a. Takes 2 inputs: a program and a set of inputs for the program,
- b. Executes the program with the given set of inputs,
- c. Outputs hash of the inputs, hash of the outputs generated by the program, and a proof attesting to the correct execution of the program.
The verifier:
-. Takes the hash of the program, hash of the inputs, and hash of the outputs, and uses them to verify the proof.
## projects examples
### Starkware Cairo
a STARK-based Turing-complete language:
each Cairo program P resides in the virtual machine’s memory, alongside the data D processed by it. 
Cairo comes with a single AIR (and thus a single Verifier — in a smart contract, WebAssembly, etc.) that can verify any Cairo program. 
Namely, the Cairo AIR verifies the computational integrity of executing P on D, and the correctness of the post-execution state of the system.
### Matter Labs Zinc
a language that compiles into bytecode which the VM can execute:
Zinc code is compiled into bytecode which can be run by Zinc VM. 
Zinc VM is a virtual machine that serves three purposes: executing arbitrary computations, generating zero-knowledge proof of performed computations, and verification of the provided proof without knowing the input data.
### Aztec Noir
Noir is a domain specific language for creating and verifying proofs. It introduces Abstract Circuit IR(ACIR).
its compilation overiew:
![noir compilation flow](https://noir-lang.github.io/book/acir_diagram.png)
### hermez zkvm: uvm
## advantages and disadvantages
### advantages
- Ease of Circuit development: easier to write code for a VM than wiring a circuit or AIRs by hand
- Simpler proving and verification key management: as arbitrary program bytecode, developers do not need to handle proving and verifying keys
### disadvantages
It is highly non-trivial to port the EVM to a zero-knowledge circuit.

have to handle the difficult task of keeping up with upgrades to the EVM, such as new precompiles or new opcodes.

Therefore, ZK-EVM which fully compatible with EVM will be promising in the future.
## cairo VM architectures
The execution trace consists of several sets of registers each having a separate function as shown below:
![execution flow](https://ethresear.ch/uploads/default/original/2X/a/a5bc58cf0a3674d1abbf6f27a20403b35b8be2e5.png)

### Instruction decoder 
is perhaps the “heaviest” part of the trace. It is responsible for decoding instructions into their binary representation and building a continuous hash of the executed instructions. It would require roughly 14 registers.
### Input tapes 
there would be two input tapes. One of the tapes will contain inputs to be pushed onto the stack, and the other tape with “hints” to aid in execution of certain instructions. Similar to program instructions, the input tape is contentiously hashed so that by the end of the execution the tape is reduced to a single hash value.
### Output tape 
this would be the tape that defines output values of the program. Though, there might be better ways to handle outputs.
### Stack registers 
will represent the stack with the first register being the top of the stack, the second register being the second from the top etc. It is important to note that the number of stack registers does not need to be fixed. Without loss of generality, it can be set to any reasonable number as required by a specific program (e.g. 4, 20, 80). This is because traces of all “unused” stack registers are just zeros, and this can be succinctly communicated to the verifier.
### Helper registers 
would be a small set of registers (e.g. 3 - 5) which could aid in execution of certain complex instructions (e.g. hashing, elliptic curve operations).